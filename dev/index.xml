<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>开发指南 on Kubernetes 实践指南</title>
    <link>https://k8s.imroc.io/dev/</link>
    <description>Recent content in 开发指南 on Kubernetes 实践指南</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh</language>
    
	<atom:link href="https://k8s.imroc.io/dev/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Go 语言编译原理与优化</title>
      <link>https://k8s.imroc.io/dev/golang-build/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://k8s.imroc.io/dev/golang-build/</guid>
      <description>编译阶段 (Compilation) debug 参数 -m 打印编译器更多想法的细节
-gcflags &amp;#39;-m&amp;#39; -S 打印汇编
-gcflags &amp;#39;-S&amp;#39; 优化和内联 默认开启了优化和内联，但是debug的时候开启可能会出现一些奇怪的问题，通过下面的参数可以禁止任何优化
-gcflags &amp;#39;-N -l&amp;#39; 内联级别：
 -gcflags=&#39;-l -l&#39; 内联级别2，更积极，可能更快，可能会制作更大的二进制文件。 -gcflags=&#39;-l -l -l&#39; 内联级别3，再次更加激进，二进制文件肯定更大，也许更快，但也许会有 bug。 -gcflags=-l=4 (4个-l)在 Go 1.11 中将支持实验性的中间栈内联优化。  逃逸分析  如果一个局部变量值超越了函数调用的生命周期，编译器自动将它逃逸到堆 如果一个通过new或make来分配的对象，在函数内即使将指针传递给了其它函数，其它函数会被内联到当前函数，相当于指针不会逃逸出本函数，最终不返回指针的话，该指针对应的值也都会分配在栈上，而不是在堆  链接阶段 (Linking)  Go 支持 internal 和 external 两种链接方式: internal 使用 go 自身实现的 linker，external 需要启动外部的 linker linker 的主要工作是将 .o (object file) 链接成最终可执行的二进制 对应命令: go tool link，对应源码: $GOROOT/src/cmd/link 通过 -ldflags 给链接器传参，参数详见: go tool link --help  关于 CGO  启用cgo可以调用外部依赖的c库 go的编译器会判断环境变量 CGO_ENABLED 来决定是否启用cgo，默认 CGO_ENABLED=1 即启用cgo 源码文件头部的 build tag 可以根据cgo是否启用决定源码是否被编译(// +build cgo 表示希望cgo启用时被编译，相反的是 // +build !</description>
    </item>
    
  </channel>
</rss>